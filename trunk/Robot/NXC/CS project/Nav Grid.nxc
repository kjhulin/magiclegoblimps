#define MOTOR_LEFT OUT_A
#define MOTOR_RIGHT OUT_C
#define MOTOR_CAMERA OUT_B

#define SPEED 50
#define SPEED_ADJUST 1
#define TURN90 180
#define TURN180 360
#define PAN_RATIO 7 / 3
#define PAN_SPEED 50

#define _SENSOR_LEFT S2
#define _SENSOR_RIGHT S3
#define SENSOR_LEFT SENSOR_2
#define SENSOR_RIGHT SENSOR_3

#define THRESHOLD 25 // 1-99

#define FOREVER while(1)

int curX;
int curY;
int destX;
int destY;
int maxX;
int maxY;
int heading; // 0-north 1-east 2-south 3-west

int LEFT_MAX = 0;
int LEFT_MIN = 100;
int RIGHT_MAX = 0;
int RIGHT_MIN = 100;

int LEFT_DARK;
int LEFT_LIGHT;
int RIGHT_DARK;
int RIGHT_LIGHT;

int MODE; // 0-atDest 1-moving 2-intersection
int last_sensor;

void motorPower(int left, int right)
{
 OnFwd(MOTOR_LEFT,left);
 OnFwd(MOTOR_RIGHT,right);
}

void stopMotors()
{
 Off(MOTOR_LEFT);
 Off(MOTOR_RIGHT);
}

void forward()
{
 motorPower(SPEED,SPEED);
}

void turnRight()
{
 ResetRotationCount(MOTOR_LEFT);
 motorPower(SPEED,-SPEED);
 while(MotorRotationCount(MOTOR_LEFT)<TURN90);
 stopMotors();
 heading = (heading + 1) % 4;
}

void turnLeft()
{
 ResetRotationCount(MOTOR_RIGHT);
 motorPower(-SPEED,SPEED);
 while(MotorRotationCount(MOTOR_RIGHT)<TURN90);
 stopMotors();
 heading = (heading) ? 3 : (heading - 1);
}

void turnAround()
{
 ResetRotationCount(MOTOR_LEFT);
 motorPower(SPEED,-SPEED);
 while(MotorRotationCount(MOTOR_LEFT)<TURN180);
 stopMotors();
 heading = (heading + 2) % 4;
}

void pan(int deg)
{
 int t = deg * PAN_RATIO;
 RotateMotor(MOTOR_CAMERA,PAN_SPEED,t);
}

void arrived()
{
 MODE = 0;
 
 int x = Random(315) + 45;
 
 pan(x);
 
 MODE = 1;
}

void error(string s)
{
 MODE = 0;
 stopMotors();
 
 
 TextOut(0,LCD_LINE4,s,true);
 Wait(30000);
 PowerDown();
}

/* turns in a circle
 * gathers min and max values for each sensor
 */
void calibrate()
{
 int left, right;
 
 ResetRotationCount(MOTOR_LEFT);
 
 motorPower(25,-25);
 
 do {
  left = SENSOR_LEFT;
  right = SENSOR_RIGHT;
  
  if(left<LEFT_MIN) LEFT_MIN = left;
  else if(left>LEFT_MAX) LEFT_MAX = left;
  
  if(right<RIGHT_MIN) RIGHT_MIN = right;
  else if(right>RIGHT_MAX) RIGHT_MAX = right;
 } while(MotorRotationCount(MOTOR_LEFT)<2000);
 
 stopMotors();
}

int sensorLeft()
{
 int left = LEFT_MAX - SENSOR_LEFT;
 int top = LEFT_MAX - LEFT_MIN;
 return (left*100/top);
}

int sensorRight()
{
 int right = RIGHT_MAX - SENSOR_RIGHT;
 int top = RIGHT_MAX - RIGHT_MIN;
 return (right*100/top);
}

task lineFollower()
{
 int x, y, pos, left, right, adj;
 
 FOREVER
 {
  while(MODE!=1);

   x = destX - curX;
   y = destY - curY;
   
   if( (heading==0 && y<=0)
     || (heading==1 && x<=0)
     || (heading==2 && y>0)
     || (heading==3 && x>0) )
   {
    turnAround();
   }
   
   while(MODE==1)
   {
    pos = sensorRight() - sensorLeft();
    adj = pos * SPEED_ADJUST;
    left = SPEED - adj;
    right = SPEED + adj;
    motorPower(left,right);
    
    if (!pos) last_sensor = pos>0;
   }
 }
}

task intersection()
{
 int direction; // 0-straight 1-left 2-right 3-arrived
 int x, y;
 
 FOREVER
 {
  x = destX - curX;
  y = destY - curY;
  
  // next intersection
  switch (heading)
  {
   case 0 : y++; break;
   case 1 : x++; break;
   case 2 : y--; break;
   case 3 : x--; break;
   default : error("next intersection"); break;
  }
  
  // next action
  if (x==0 && y==0)
  {
   direction = 3;
  }
  else if (heading==0 && y==0) // heading north approaching destY
  {
   direction = (x<0) ? 1 : 2;
  }
  else if (heading==1 && x==0) // heading east approaching destX
  {
   direction = (y<0) ? 2 : 1;
  }
  else if (heading==2 && y==0) // heading south approaching destY
  {
   direction = (x<0) ? 2 : 1;
  }
  else if (heading==3 && x==0) // heading west approaching destX
  {
   direction = (y<0) ? 1 : 2;
  }
  else // keep going straight
  {
   direction = 0;
  }
  
  // found intersection
  //if (LEFT_DARK && RIGHT_DARK)
  while( !LEFT_DARK || !RIGHT_DARK );
  {
   // increment current position
   switch (heading)
   {
    case 0 : curX++; break;
    case 1 : curY++; break;
    case 2 : curX--; break;
    case 3 : curY--; break;
    default: error("update position"); break;
   }
   
   // perform required turn/action
   if (direction)
   {
    MODE = 2;
    
    stopMotors();
    
    switch (direction)
    {
     case 1 : turnLeft(); break;
     case 2 : turnRight(); break;
     case 3 : arrived(); break;
     default: error("perform action"); break;
    }
   }
  }
 }
}

task sensors()
{
 int left, right;

 FOREVER
 {
  left = sensorLeft();
  right = sensorRight();
  
  LEFT_DARK = left < THRESHOLD;
  LEFT_LIGHT = left > (100-THRESHOLD);
  RIGHT_DARK = right < THRESHOLD;
  RIGHT_LIGHT = right > (100-THRESHOLD);
 }
}

task main()
{
 Precedes(lineFollower,intersection,sensors);

 calibrate();
 
 while(!ButtonPressed(BTNCENTER,true));
 
 curX = 0;
 curY = 0;
 maxX = 5;
 maxY = 5;
 heading = 0;
 MODE = 1;
 
 SetSensorType(_SENSOR_LEFT, SENSOR_TYPE_LIGHT_ACTIVE);
 SetSensorType(_SENSOR_RIGHT, SENSOR_TYPE_LIGHT_ACTIVE);
 SetSensorMode(_SENSOR_LEFT, SENSOR_MODE_RAW);
 SetSensorMode(_SENSOR_RIGHT, SENSOR_MODE_RAW);
}
