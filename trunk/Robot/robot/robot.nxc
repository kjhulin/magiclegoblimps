/*
  @ commands
  - start   (one time only)
  - forward
  - forward ms
  - left
  - right
  - turnaround
  - pan deg
  - stop
  
  @ start up receive
  - line type (black/white)
  - starting X
  - starting Y
  - starting heading
  
  @ start up send
  - battery level
  
  @ feedback
  - curX (int)
  - curY (int)
  - tachometer count (int)
  - heading (int)
  - battery level (int)
  - pan deg (int)
  - at intersection (boolean)
*/

// controller
#define USE_CONTROLLER 1   // 0-no 1-yes

// mailboxes
#define OUTBOX 0  // to controller
#define INBOX 1   // from controller
#define CAMERABOX 2 // if needed

// wheels
#define MOTOR_LEFT OUT_A
#define MOTOR_RIGHT OUT_C
#define MOTORS OUT_AC

#define SPEED 40
#define SPEED_ADJUST 5    // > 0
#define SPEED_TURN 20
#define SPEED_PAN 10
#define TIME_TURN 300     // milliseconds
#define TURN90 360
#define TURN180 360

// camera
#define MOTOR_CAMERA OUT_B

#define PAN_RATIO 7 / 3
#define PAN_SPEED 50

// light sensors
#define _SENSOR_LEFT S2
#define _SENSOR_RIGHT S3
#define SENSOR_LEFT SENSOR_2
#define SENSOR_RIGHT SENSOR_3

#define THRESHOLD 100
#define SENSOR_MAX 1023

// sonar sensor
#define _SONAR S4
#define SONAR SensorUS(_SONAR)

#define NEAR 15        // cm

// errors

// MODE
#define STOPPED 0
#define IDLE 1
#define DESTINATION 2
#define LINE_FOLLOW 3
#define INTERSECTION 4
#define TURNLEFT 5
#define TURNRIGHT 6
#define TURNAROUND 7
#define SONARBLOCK 8

// heading
#define NORTH 0
#define EAST 1
#define SOUTH 2
#define WEST 3

// destination
#define STRAIGHT 0
#define LEFT 1
#define RIGHT 2
#define ARRIVED 3

// action
#define STOP 0
#define LEFT 1
#define RIGHT 2
#define TURNAROUND 3
#define PAN 4
#define FORWARD 5
#define FORWARD_X 6

// other
#define FOREVER while(1)

// location and heading
int curX;
int curY;
int destX;
int destY;
int maxX;
int maxY;
int homeX;
int homeY;
int tacho = 0;
int heading;    // 0-north 1-east 2-south 3-west
int curPan;
int destPan;

// sensors
int LEFT_DARK;
int LEFT_LIGHT;
int RIGHT_DARK;
int RIGHT_LIGHT;

int LEFT_MAX = 0;
int LEFT_MIN = 100;
int RIGHT_MAX = 0;
int RIGHT_MIN = 100;

// others
int MODE = 0; // 0-dest 1-moving 2-intersection
int last_sensor = 0;
int status = 0; // flags
int action = STOP;
int actionValue = 0;

/*
 *   DEPENDENT FUNTIONS
 */

void motorPower(int left, int right)
{
 OnFwd(MOTOR_LEFT, left);
 OnFwd(MOTOR_RIGHT, right);
}

int battery()
{
 return BatteryLevel() / 90;
}

void send(string s)
{
 SendMessage(OUTBOX,s);
}

string read( int box, int clear )
{
 string msg;
 ReceiveMessage( box, clear, msg );
 return msg;
}

/*
 *    INDEPENDINT FUNCTIONS
 */
void stopWheels()
{
 motorPower(0,0);
}

void forward()
{
 motorPower(SPEED, SPEED);
}

void forwardWait(int ms)
{
 forward();
 Wait(ms);
 stopWheels();
}

void reverse()
{
 motorPower( -SPEED, -SPEED);
}

void turnRight()
{
 motorPower(SPEED_TURN, -SPEED_TURN / 2);
 //Wait(TIME_TURN);
  ResetRotationCount(MOTOR_LEFT);
 while(MotorRotationCount(MOTOR_LEFT)<TURN90);
 stopWheels();
 heading = (heading + 1) % 4;
}

void turnRightWait(int before, int after)
{
 forwardWait(before);
 turnRight();
 forwardWait(after);
}

void turnLeft()
{
 motorPower(-SPEED_TURN / 2, SPEED_TURN);
 //Wait(TIME_TURN);
 ResetRotationCount(MOTOR_RIGHT);
 while(MotorRotationCount(MOTOR_RIGHT)<TURN90);
 stopWheels();
 heading = (heading) ? (heading - 1) : WEST;
}

void turnLeftWait(int before, int after)
{
 forwardWait(before);
 turnLeft();
 forwardWait(after);
}

void turnAround()
{
 motorPower(SPEED_TURN, -SPEED_TURN);
 //Wait(TIME_TURN);
  ResetRotationCount(MOTOR_LEFT);
 while(MotorRotationCount(MOTOR_LEFT)<TURN180);
 stopWheels();
 heading = (heading + 2) % 4;
}

void arrived()
{
 MODE = DESTINATION;
}

void setStatus(int s)
{
 status |= s;
}

void calibrate()
{
 int left, right;
 
 motorPower(25,-25);
 repeat(5)
 {
  Wait(100);
  left = SENSOR_LEFT;
  right = SENSOR_RIGHT;

  if(left<LEFT_MIN) LEFT_MIN = left;
  else if(left>LEFT_MAX) LEFT_MAX = left;

  if(right<RIGHT_MIN) RIGHT_MIN = right;
  else if(right>RIGHT_MAX) RIGHT_MAX = right;
 }
 stopWheels();
 motorPower(-25,25);
 repeat(10);
 {
  Wait(100);
  left = SENSOR_LEFT;
  right = SENSOR_RIGHT;

  if(left<LEFT_MIN) LEFT_MIN = left;
  else if(left>LEFT_MAX) LEFT_MAX = left;

  if(right<RIGHT_MIN) RIGHT_MIN = right;
  else if(right>RIGHT_MAX) RIGHT_MAX = right;
 }
 stopWheels();
 motorPower(25,-25);
 repeat(5);
 {
  Wait(100);
  left = SENSOR_LEFT;
  right = SENSOR_RIGHT;

  if(left<LEFT_MIN) LEFT_MIN = left;
  else if(left>LEFT_MAX) LEFT_MAX = left;

  if(right<RIGHT_MIN) RIGHT_MIN = right;
  else if(right>RIGHT_MAX) RIGHT_MAX = right;
 }
}

void pan(int deg)
{
 int t = deg * PAN_RATIO;
 RotateMotor(MOTOR_CAMERA,PAN_SPEED,t);
}

/*
 *      TASKS SEMI-AUTONOMOUS
 */
 
task lineFollower()
{
 int pos, adj, left, right;
 
 FOREVER
 {
  while(MODE==LINE_FOLLOW)
  {
   if(SONAR<=NEAR)
   {
    MODE = SONAR;
    stopWheels();
    while(SONAR<=NEAR);
    MODE = LINE_FOLLOW;
   }

   pos = SENSOR_RIGHT - SENSOR_LEFT;
   adj = pos / SPEED_ADJUST;
   left = SPEED + adj;
   right = SPEED - adj;
   motorPower(left,right);

   //if (!pos) last_sensor = (pos>0)? 0 : 1;
   
   if( LEFT_DARK && RIGHT_DARK )
   {
    MODE = INTERSECTION;
    stopWheels();
   }
  }
  stopWheels();
 }
}

/* turn the camera by a degree
   +deg : clockwise
   -deg : counter-clockwise
*/


task display()
{
 string out;
 string in;
 FOREVER
 {
    ClearScreen();
    ReceiveMessage(OUTBOX,false,out);
    //ReceiveMessage(INBOX,false,in)
    TextOut(0,LCD_LINE3,out,false);
    //TextOut(0,LCD_LINE5,in,false);
    switch(MODE)
    {
     case IDLE : TextOut(0,0,"IDLE",false); break;
     case DESTINATION : TextOut(0,0,"DESTINATION",false); break;
     case LINE_FOLLOW : TextOut(0,0,"LINE_FOLLOW",false); break;
     case INTERSECTION : TextOut(0,0,"INTERSECTION",false); break;
     case TURNLEFT : TextOut(0,0,"TURNLEFT",false); break;
     case TURNRIGHT : TextOut(0,0,"TURNRIGHT",false); break;
     case TURNAROUND : TextOut(0,0,"TURNAROUND",false); break;
     case SONARBLOCK : TextOut(0,0,"SONARBLOCK",false); break;
     default : TextOut(0,0,"Invalid",false);
    }
    
    Wait(100);
 }
}

task camera()
{
 int deg;
 string msg;
 int len;

 FOREVER
 {
  ReceiveMessage(INBOX,false,msg);

  len = StrLen(msg);

  if( len >= 3 && SubStr(msg,0,3) == "pan" )
  {
   ReceiveMessage(INBOX,true,msg);

   msg = SubStr( msg, 4, len );
   deg = StrToNum( msg );
   curPan += deg;

   pan( deg );
  }
 }
}

task receiveCommand()
{
 string msg = "";
 string cmd = "";
 int space;
 int value;
 int i;
 int len;

 FOREVER
 {
  ReceiveMessage(INBOX,false,msg);

  len = StrLen(msg);

  if(len>0)
  {
   if( len >= 3 && SubStr(msg,0,3) == "pan" )
   {
    continue;
   }
   
   ReceiveMessage(INBOX,true,msg);
   
   len = StrLen(msg);
   
   if( len >= 4 && SubStr(msg,0,4) == "stop" )
   {
    MODE = STOPPED;
    stopWheels();
    continue;
   }
   
   //if( action != IDLE || action != STOP ) { continue; }

   if( len >= 4 && SubStr(msg,0,4) == "left" )
   {
    action = LEFT;
    MODE = TURNLEFT;
    turnLeftWait( 400, 200 );
    stopWheels();
    MODE = IDLE;
   }
   else if( len >= 5 && SubStr(msg,0,5) == "right" )
   {
    action = RIGHT;
    MODE = TURNRIGHT;
    turnRightWait( 400, 200 );
    stopWheels();
    MODE = IDLE;
   }
   else if( len >= 10 && SubStr(msg,0,10) == "turnaround" )
   {
    action = TURNAROUND;
    MODE = TURNAROUND;
    turnAround();
    MODE = IDLE;
   }
   else if( len >= 7 && SubStr(msg,0,7) == "forward" )
   {
    if( len == 7 )
    {
     action = FORWARD;
     MODE = LINE_FOLLOW;
    }
    else
    {
     msg = SubStr(msg,8,len-8);
     value = NumToStr( msg );
     
     action = FORWARD_X;
     actionValue = value;
     MODE = LINE_FOLLOW;
     Wait(value); // split up into intervals?
     if( MODE != INTERSECTION )
     {
      MODE = DESTINATION;
     }
     stopWheels();
    }
   }
   else
   {
    PlayTone(1000, 50);
   }
   
   /*
   space = -1;
   value = -1;

   for( i=0; i<len; i++ )
   {
    if( SubStr(msg,i,i+1) == " " )
    {
     space = i;
     break;
    }
   }

   cmd = SubStr(msg,0,space);
   msg = SubStr(msg,i+1,len);
   value = StrToNum(msg);
   value = (space>0)?value:0;
   
   switch( cmd )
   {
    case "left" :
         action = LEFT;
         MODE = TURNING;
         turnLeftWait( 400, 200 );
         MODE = IDLE;
         break;
    case "right" :
         action = RIGHT;
         MODE = TURNING;
         turnRightWait( 400, 200 );
         MODE = IDLE;
         break;
    case "turnaround" :
         action = TURNAROUND;
         MODE = TURNING;
         turnAround();
         MODE = IDLE;
         break;
    case "forward" :
         if( value )
         {
          action = FORWARD_X;
          actionValue = value;
          MODE = LINE_FOLLOW;
          Wait(value);
          if( MODE != INTERSECTION )
          {
           MODE = DESTINATION;
          }
          stopWheels();
         }
         else
         {
          action = FORWARD;
          MODE = LINE_FOLLOW;
         }
         break;
    default :
         break;
   }
   */
  }
 }
}

/*
 *    TASK AUTONOMOUS
 */

task lineFollower_auto()
{
  int x, y, pos, left, right, adj;
  
  FOREVER
  {
   while(MODE!=LINE_FOLLOW);

    x = destX - curX;
    y = destY - curY;
    
    if( (heading==NORTH && y<=0)
        || (heading==EAST && x<=0)
        || (heading==SOUTH && y>0)
        || (heading==WEST && x>0) )
     {
      turnAround();
     }

    while(MODE==LINE_FOLLOW)
    {
     if(SONAR<=NEAR)
     {
      stopWheels();
      while(SONAR<=NEAR);
     }
     
     pos = SENSOR_RIGHT - SENSOR_LEFT;
     adj = pos / SPEED_ADJUST;
     left = SPEED + adj;
     right = SPEED - adj;
     motorPower(left,right);
     
     if (!pos) last_sensor = (pos>0)? 0 : 1;
    }
  }
}

task intersection_auto()
{
 int direction, x, y;
 
 FOREVER
 {
  x = destX - curX;
  y = destY - curY;
  
  // next intersection
  switch (heading)
  {
   case NORTH : y--; break;
   case EAST : x--; break;
   case SOUTH : y++; break;
   case WEST : x++; break;
   default : break;
  }
  
  // next action
  if (x==0 && y==0)
  {
   direction = ARRIVED;
  }
  else if (heading==NORTH && y==0) // heading north approaching destY
  {
   direction = (x<0) ? LEFT : RIGHT;
  }
  else if (heading==EAST && x==0) // heading east approaching destX
  {
   direction = (y<0) ? RIGHT : LEFT;
  }
  else if (heading==SOUTH && y==0) // heading south approaching destY
  {
   direction = (x<0) ? RIGHT : LEFT;
  }
  else if (heading==WEST && x==0) // heading west approaching dextX
  {
   direction = (y<0) ? LEFT : RIGHT;
  }
  else // keep going straight
  {
   direction = STRAIGHT;
  }
  
  // found intersection
  //if (LEFT_DARK && RIGHT_DARK)
  while( !LEFT_DARK || !RIGHT_DARK );
  {
   // increment current position
   switch (heading)
   {
    case NORTH : curX++; break;
    case EAST : curY++; break;
    case SOUTH : curX--; break;
    case WEST : curY--; break;
    default: break;
   }
   
   setStatus(INTERSECTION);
   
   // perform required turn/action
   if( direction )
   {
    MODE = INTERSECTION;
    
    stopWheels();
    
    switch (direction)
    {
     case LEFT : turnLeftWait( 400, 200 ); break;
     case RIGHT : turnRightWait( 400, 200 ); break;
     case ARRIVED : arrived(); break;
     default: break;
    }
   }
  }
 }
}

/*
 *    TASKS SHARED
 */

// dark line, light ground
task sensor()
{
 int left, right;
 
 FOREVER
 {
  left = SENSOR_LEFT;
  right = SENSOR_RIGHT;
  
  LEFT_DARK = left < THRESHOLD;
  LEFT_LIGHT = left > (SENSOR_MAX - THRESHOLD);
  RIGHT_DARK = right < THRESHOLD;
  RIGHT_LIGHT = right < (SENSOR_MAX - THRESHOLD);
 }
}

// light line, dark ground
task sensors_white()
{
 int left, right;
 
 FOREVER
 {
  left = SENSOR_LEFT;
  right = SENSOR_RIGHT;

  LEFT_LIGHT = left < THRESHOLD;
  LEFT_DARK = left > (SENSOR_MAX - THRESHOLD);
  RIGHT_LIGHT = right < THRESHOLD;
  RIGHT_DARK = right < (SENSOR_MAX - THRESHOLD);
 }
}

/*
 * 1. current location (x,y)
 * 2. current heading
 * 3. current tachometer count
 * 4. current camera pan
 * 5. battery life percent
 * 6. status flags
 *
 * if OUTBOX is empty then fill it
 */
task sendFeedBack()
{
   const string d = " ";
   string x, y, t, h, c, b, s, stat, msg;

   FOREVER
   {
       x = NumToStr(curX);
       y = NumToStr(curY);
       t = NumToStr(tacho);
       h = NumToStr(heading);
       c = NumToStr(curPan);
       b = NumToStr(battery());
       stat = NumToStr(status);
       s = StrCat(x,d,y,d,t,d,h,d,c,d,b,d,stat);
       
      ReceiveMessage(OUTBOX,false,msg);
      
      if( StrLen(msg) > 0 )
      {
       ReceiveMessage(OUTBOX,true,msg);
      }
      
      //SendResponseString(OUTBOX,s);
      SendMessage(OUTBOX,s);
      
      Wait(25);

      status = 0;
   }
}

task main()
{

 
 if(USE_CONTROLLER)
 {
  TextOut(0,0,"Controller",true);
  string msg;
  SendMessage(OUTBOX,"hello");
  do {
    ReceiveMessage(INBOX,true,msg);
  } while( msg != "start" );
  
  Precedes(lineFollower,camera,receiveCommand,sendFeedBack,display);
 }
 else // without controller
 {
  TextOut(0,0,"Autonomous",true);
  Precedes(lineFollower_auto,intersection_auto,sensor);

  // initials
  curX = 1;
  curY = 0;
  maxX = 2;
  maxY = 2;
  heading = 0;
  MODE = 1;
  destX = 2;
  destY= 1;
 }
 
 // set light sensors
 /*
 SetSensorType(_SENSOR_LEFT, SENSOR_TYPE_LIGHT_ACTIVE);
 SetSensorType(_SENSOR_RIGHT, IN_TYPE_LIGHT_ACTIVE);
 //*/
 SetSensorMode(_SENSOR_LEFT, SENSOR_MODE_RAW);
 SetSensorMode(_SENSOR_RIGHT, SENSOR_MODE_RAW);
 
 // set sonar sensor
 SetSensorLowspeed(_SONAR);
 
 //calibrate();
 
 Wait(1000);
 }
