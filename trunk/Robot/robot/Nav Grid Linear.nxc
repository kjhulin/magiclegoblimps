#define MOTOR_LEFT OUT_A
#define MOTOR_RIGHT OUT_C
#define MOTOR_CAMERA OUT_B

#define SPEED 40
#define SPEED_ADJUST 1
#define TURN90 180
#define TURN180 360
#define PAN_RATIO 7 / 3
#define PAN_SPEED 50

#define _SENSOR_LEFT S2
#define _SENSOR_RIGHT S3
#define SENSOR_LEFT SENSOR_2
#define SENSOR_RIGHT SENSOR_3

#define THRESHOLD 25 // 1-99
#define SENSOR_MAX 1023

#define FOREVER while(1)

int curX;
int curY;
int destX;
int destY;
int maxX;
int maxY;
int heading; // 0-north 1-east 2-south 3-west

int LEFT_MAX = 0;
int LEFT_MIN = SENSOR_MAX;
int RIGHT_MAX = 0;
int RIGHT_MIN = SENSOR_MAX;

int LEFT_DARK;
int LEFT_LIGHT;
int RIGHT_DARK;
int RIGHT_LIGHT;
int DARK;

int MODE; // 0-atDest 1-moving 2-intersection
int last_sensor;

void motorPower(int left, int right)
{
 OnFwd(MOTOR_LEFT,left);
 OnFwd(MOTOR_RIGHT,right);
}

void stopMotors()
{
 Off(MOTOR_LEFT);
 Off(MOTOR_RIGHT);
}

void forward()
{
 motorPower(SPEED,SPEED);
}

void forwardWait(int ms)
{
 forward();
 Wait(ms);
 stopMotors();
}

void turnRight()
{
 ResetRotationCount(MOTOR_LEFT);
 motorPower(SPEED,-SPEED);
 while(MotorRotationCount(MOTOR_LEFT)<TURN90);
 stopMotors();
 heading = (heading + 1) % 4;
}

void turnRightWait(int before, int after)
{
 forwardWait(before);
 turnRight();
 forwardWait(after);
}

void turnLeft()
{
 ResetRotationCount(MOTOR_RIGHT);
 motorPower(-SPEED,SPEED);
 while(MotorRotationCount(MOTOR_RIGHT)<TURN90);
 stopMotors();
 heading = (heading) ? (heading - 1) : 3;
}

void turnLeftWait(int before, int after)
{
 forwardWait(before);
 turnLeft();
 forwardWait(after);
}

void turnAround()
{
 ResetRotationCount(MOTOR_LEFT);
 motorPower(SPEED,-SPEED);
 while(MotorRotationCount(MOTOR_LEFT)<TURN180);
 stopMotors();
 heading = (heading + 2) % 4;
}

void pan(int deg)
{
 int t = deg * PAN_RATIO;
 RotateMotor(MOTOR_CAMERA,PAN_SPEED,t);
}

void arrived()
{
 /*
 MODE = 0;

 int x = Random(315) + 45;

 pan(x);

 MODE = 1;
 */
 
 stopMotors();
 
 Stop(1);
}

void error(string s)
{
 MODE = 0;
 stopMotors();


 TextOut(0,LCD_LINE4,s,true);
 Wait(30000);
 PowerDown();
}

/* turns in a circle
 * gathers min and max values for each sensor
 */
void calibrate()
{
 int left, right;

 ResetRotationCount(MOTOR_LEFT);

 motorPower(25,-25);

 do {
  left = SENSOR_LEFT;
  right = SENSOR_RIGHT;

  if(left<LEFT_MIN) LEFT_MIN = left;
  else if(left>LEFT_MAX) LEFT_MAX = left;

  if(right<RIGHT_MIN) RIGHT_MIN = right;
  else if(right>RIGHT_MAX) RIGHT_MAX = right;
 } while(MotorRotationCount(MOTOR_LEFT)<720);

 stopMotors();
}

int sensorLeft()
{
 int value = SENSOR_LEFT - LEFT_MIN;
 int range = LEFT_MAX - LEFT_MIN;
 return ( value*100 / range );
}

int sensorRight()
{
 int value = SENSOR_RIGHT - RIGHT_MIN;
 int range = RIGHT_MAX - RIGHT_MIN;
 return ( value*100 / range);
}

int maxSensor()
{
 int left = sensorLeft();
 int right = sensorRight();
 return (left>right) ? left : right;
}

void run()
{
 int x, y, pos, left, right, adj, direction, sensor;
 
 FOREVER
 {
  x = destX - curX;
  y = destY - curY;
  
  /*
  if( (heading==0 && y<=0)
     || (heading==1 && x<=0)
     || (heading==2 && y>0)
     || (heading==3 && x>0) )
   {
    turnAround();
   }
   */
   
  switch (heading)
  {
   case 0 : y--; break;
   case 1 : x--; break;
   case 2 : y++; break;
   case 3 : x++; break;
   default : error("next intersection"); break;
  }
   
   // next action
  if (x==0 && y==0)
  {
   direction = 3;
  }
  else if (heading==0 && y==0) // heading north approaching destY
  {
   direction = (x<0) ? 1 : 2;
  }
  else if (heading==1 && x==0) // heading east approaching destX
  {
   direction = (y<0) ? 2 : 1;
  }
  else if (heading==2 && y==0) // heading south approaching destY
  {
   direction = (x<0) ? 2 : 1;
  }
  else if (heading==3 && x==0) // heading west approaching destX
  {
   direction = (y<0) ? 1 : 2;
  }
  else // keep going straight
  {
   direction = 0;
  }
   
  // follow line, stop at intersection
  do
  {
   left = sensorLeft();
   right = sensorRight();
   pos = right - left;
   //pos = sensorRight() - sensorLeft();
   adj = pos * SPEED_ADJUST;
   left = SPEED - adj;
   right = SPEED + adj;
   //motorPower(left,right);
   
   TextOut(0,LCD_LINE4,NumToStr(left),true);
   TextOut(50,LCD_LINE4,NumToStr(right),false);
   
   sensor = (left>right)? left : right;
   
  } while( sensor > THRESHOLD );
  
  stopMotors();
  while(1);
  
  // intersection found
  {
   // increment current position
   switch (heading)
   {
    case 0 : curX++; break;
    case 1 : curY++; break;
    case 2 : curX--; break;
    case 3 : curY--; break;
    default: error("update position"); break;
   }

   // perform required turn/action
   if (direction)
   {
    //stopMotors();
    
    switch (direction)
    {
     case 1 : turnLeftWait( 400, 200 ); break;
     case 2 : turnRightWait( 400, 200 ); break;
     case 3 : arrived(); break;
     default: error("perform action"); break;
    }
   }
  }
  
 }
}

task main()
{

 SetSensorType(_SENSOR_LEFT, SENSOR_TYPE_LIGHT_ACTIVE);
 SetSensorType(_SENSOR_RIGHT, SENSOR_TYPE_LIGHT_ACTIVE);
 SetSensorMode(_SENSOR_LEFT, SENSOR_MODE_RAW);
 SetSensorMode(_SENSOR_RIGHT, SENSOR_MODE_RAW);

 calibrate();

 TextOut(0,0, NumToStr(LEFT_MIN),true);
 TextOut(50,0,NumToStr(RIGHT_MIN),false);
 TextOut(0,30,NumToStr(LEFT_MAX),false);
 TextOut(50,30,NumToStr(RIGHT_MAX),false);
 
 SetSensorType(_SENSOR_LEFT, SENSOR_TYPE_LIGHT_INACTIVE);
 SetSensorType(_SENSOR_RIGHT, SENSOR_TYPE_LIGHT_INACTIVE);

 while(!ButtonPressed(BTNCENTER,true));
 Wait(5000);
 
 SetSensorType(_SENSOR_LEFT, SENSOR_TYPE_LIGHT_ACTIVE);
 SetSensorType(_SENSOR_RIGHT, SENSOR_TYPE_LIGHT_ACTIVE);

 curX = 0;
 curY = 0;
 destX = 0;
 destY = 1;
 maxX = 5;
 maxY = 5;
 heading = 0;

 run();
}
