#include "robot.h"

#define MOTOR_LEFT OUT_A
#define MOTOR_RIGHT OUT_C
#define MOTOR_CAMERA OUT_B

#define SPEED 40
#define SPEED_ADJUST 1
#define TURN90 180
#define TURN180 360
#define PAN_RATIO 7 / 3
#define PAN_SPEED 50

#define _SENSOR_LEFT S2
#define _SENSOR_RIGHT S3
#define SENSOR_LEFT SENSOR_2
#define SENSOR_RIGHT SENSOR_3

#define THRESHOLD 25 // 1-99
#define SENSOR_MAX 1023

#define FOREVER while(1)

int destX;
int destY;
int maxX;
int maxY;

int LEFT_DARK;
int LEFT_LIGHT;
int RIGHT_DARK;
int RIGHT_LIGHT;
int DARK;

int last_sensor;



void arrived()
{
 /*
 MODE = 0;

 int x = Random(315) + 45;

 pan(x);

 MODE = 1;
 */
 
 stopMotors();
 
 Stop(1);
}

void error(string s)
{
 MODE = 0;
 stopMotors();


 TextOut(0,LCD_LINE4,s,true);
 Wait(30000);
 PowerDown();
}

/* turns in a circle
 * gathers min and max values for each sensor
 */
void calibrate()
{
 int left, right;

 ResetRotationCount(MOTOR_LEFT);

 motorPower(25,-25);

 do {
  left = SENSOR_LEFT;
  right = SENSOR_RIGHT;

  if(left<LEFT_MIN) LEFT_MIN = left;
  else if(left>LEFT_MAX) LEFT_MAX = left;

  if(right<RIGHT_MIN) RIGHT_MIN = right;
  else if(right>RIGHT_MAX) RIGHT_MAX = right;
 } while(MotorRotationCount(MOTOR_LEFT)<720);

 stopMotors();
}

void run()
{
 int x, y, pos, left, right, adj, direction, sensor;
 
 FOREVER
 {
  x = destX - curX;
  y = destY - curY;
  
  /*
  if( (heading==0 && y<=0)
     || (heading==1 && x<=0)
     || (heading==2 && y>0)
     || (heading==3 && x>0) )
   {
    turnAround();
   }
   */
   
  switch (heading)
  {
   case 0 : y--; break;
   case 1 : x--; break;
   case 2 : y++; break;
   case 3 : x++; break;
   default : error("next intersection"); break;
  }
   
   // next action
  if (x==0 && y==0)
  {
   direction = 3;
  }
  else if (heading==0 && y==0) // heading north approaching destY
  {
   direction = (x<0) ? 1 : 2;
  }
  else if (heading==1 && x==0) // heading east approaching destX
  {
   direction = (y<0) ? 2 : 1;
  }
  else if (heading==2 && y==0) // heading south approaching destY
  {
   direction = (x<0) ? 2 : 1;
  }
  else if (heading==3 && x==0) // heading west approaching destX
  {
   direction = (y<0) ? 1 : 2;
  }
  else // keep going straight
  {
   direction = 0;
  }
   
  // follow line, stop at intersection
  do
  {
   checkSonar();
   
   left = sensorLeft();
   right = sensorRight();
   pos = right - left;
   //pos = sensorRight() - sensorLeft();
   adj = pos * SPEED_ADJUST;
   left = SPEED - adj;
   right = SPEED + adj;
   //motorPower(left,right);
   
   TextOut(0,LCD_LINE4,NumToStr(left),true);
   TextOut(50,LCD_LINE4,NumToStr(right),false);
   
   sensor = (left>right)? left : right;
   
  } while( sensor > THRESHOLD );
  
  stopMotors();
  while(1);
  
  // intersection found
  {
   // increment current position
   switch (heading)
   {
    case 0 : curX++; break;
    case 1 : curY++; break;
    case 2 : curX--; break;
    case 3 : curY--; break;
    default: error("update position"); break;
   }

   // perform required turn/action
   if (direction)
   {
    //stopMotors();
    
    switch (direction)
    {
     case 1 : turnLeftWait( 400, 200 ); break;
     case 2 : turnRightWait( 400, 200 ); break;
     case 3 : arrived(); break;
     default: error("perform action"); break;
    }
   }
  }
  
 }
}

task main()
{
 setSonarRaw();
 setLightRaw();
 setLightOn();

 calibrate();

 TextOut(0,0, NumToStr(LEFT_MIN),true);
 TextOut(50,0,NumToStr(RIGHT_MIN),false);
 TextOut(0,30,NumToStr(LEFT_MAX),false);
 TextOut(50,30,NumToStr(RIGHT_MAX),false);

 setLightOff();

 while(!ButtonPressed(BTNCENTER,true));
 Wait(5000);

 setLightOn();
 
 curX = 0;
 curY = 0;
 destX = 0;
 destY = 1;
 maxX = 5;
 maxY = 5;
 heading = 0;

 run();
}
