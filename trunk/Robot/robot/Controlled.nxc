#include "robot.h"

#define CAMBOX 3

mutex mailbox;

bool testCommand(string msg, string cmd)
{
 int len = StrLen(cmd);
 return (StrLen(msg) >= len && SubStr(msg,0,len) == cmd);
}

string readInbox(bool clear)
{
 Acquire(mailbox);
 string msg;
 ReceiveMessage(INBOX,clear,msg);
 Release(mailbox);
 return msg;
}

task receiveCommand()
{
 string msg = "";

 FOREVER
 {
  setLightOff();

  msg = readInbox(false);
  
  if(StrLen(msg)>0)
  {
  /*
   if( testCommand(msg,"stop")
    || testCommand(msg,"pan")
    || testCommand(msg,"pid") )
   {
    continue;
   }
   */
   
   msg = readInbox(true);

   if( testCommand(msg,"left" ) || testCommand(msg,"4") )
   {
    /*turnLeftWait( 400, 300 );
    lineCorrect();*/
    turnLeftLine();
    stopWheels();
   }
   else if( testCommand(msg,"right" ) || testCommand(msg,"6") )
   {
    /*turnRightWait( 400, 300 );
    lineCorrect();*/
    turnRightLine();
    stopWheels();
   }
   else if( testCommand(msg,"turnaround" ) || testCommand(msg,"2") )
   {
    //turnAround();
    turnaroundLine();
   }
   else if( testCommand(msg,"calibrate" ) || testCommand(msg,"5") )
   {
    //calibrate();
    calibrateLine();
   }

   else if( testCommand(msg,"correct") )
   {
    lineCorrect();
   }
   else if( testCommand(msg,"forward") || testCommand(msg,"8") )
   {
     lineFollow();
   }

   else if( testCommand(msg,"coordinates") )
   {
    int i,x,y,len=StrLen(msg);
    
    // get first space
    for( i=0; i<len; i++)
    {
     if( SubStr(msg,i,1) == " ")
     {
      x=i+1;
     }
    }
    // get second space
    for(; i<len; i++)
    {
     if( SubStr(msg,i,1) == " " )
     {
      y=i+1;
     }
    }
    // test for extra space
    for(; i<len; i++)
    {
     if( SubStr(msg,i,1) == " " )
     {
      break;
     }
    }
    //get new curX and curY
    if( x<y && y<i )
    {
     string t = SubStr(msg,x,y-x-1);
     curX = StrToNum(t);
     t = SubStr(msg,y,i-y);
     curY = StrToNum(t); // might need to i-y+1
    }
    else
    {
     PlayTone(10000,50);
    }

   }
   //*/
   else
   {
    PlayTone(1000,50);
   }

  }
 }
}

task cmdPan()
{
 string msg;

 FOREVER
 {
  ReceiveMessage(CAMBOX,false,msg);

  if( StrLen(msg)>0 )
  {
   ReceiveMessage(CAMBOX,true,msg);
   
   if( !(testCommand(msg,"pan")) )
       continue;

   msg = SubStr( msg, 4, StrLen(msg) );

   pan( StrToNum( msg ) ); // send deg
  }
 }
}


// only stops forward command
task cmdStop()
{
 string msg;

 FOREVER
 {
  msg = readInbox(false);

  if( StrLen(msg)>0 && testCommand(msg,"stop") )
  {
    msg = readInbox(true);

//   StopTask(receiveCommand); // requires Enhanced Firmware
//   StartTask(receiveCommand);

    setStatus(STOPPED);
    
    repeat(10)
     stopWheels();
  }
 }
}

task sendFeedBack()
{
   const string d = " ";
   string x, y, t, h, p, b, str, s, msg;

   FOREVER
   {
       x = NumToStr(curX);
       y = NumToStr(curY);
       h = NumToStr(heading);
       p = NumToStr(curPan);
       b = NumToStr(battery());
       s = NumToStr(STATUS);
       str = StrCat(x,d,y,d,h,d,p,d,b,d,s);

      ReceiveMessage(OUTBOX,false,msg);

      if( StrLen(msg) > 0 )
      {
       ReceiveMessage(OUTBOX,true,msg);
      }

      SendResponseString(OUTBOX,str);

      Wait(23);
   }
}


task main()
{
 Precedes(receiveCommand,cmdPan,cmdStop,sendFeedBack);
 
 string msg;
 do{
    ReceiveMessage(INBOX,true,msg);
 } while(StrLen(msg)>0);

 setSonarRaw();
 setLightRaw();
}
